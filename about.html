<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CHID - About</title>
    <link rel="icon" href="img/main/favicon.png" type="image/png">
    
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" />

    <style>
        /* [기본 설정] */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Pretendard', 'Inter', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background-color: #ffffff;
            color: #111111; 
            min-height: 100vh;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, background-color 0.5s ease, color 0.5s ease;
            overflow-x: hidden; 
            -webkit-font-smoothing: antialiased;
            -webkit-tap-highlight-color: transparent;
        }
        
        body.fade-in { opacity: 1; }
        
        body.dark-mode { background-color: #050505; color: #ffffff; }
        body.dark-mode .sticky-stage { background-color: #050505; }
        body.dark-mode .content-section { background-color: #050505; }

        /* [헤더 스타일] */
        header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 20px 40px; 
            width: 100%;
            position: fixed; top: 0; left: 0; z-index: 100;
            background-color: rgba(255, 255, 255, 0); 
            backdrop-filter: blur(0px); 
            transition: all 0.4s ease;
            height: 90px;
        }

        /* 스크롤 시 스타일 */
        header.scrolled {
            background-color: rgba(255, 255, 255, 0.85); 
            backdrop-filter: blur(12px); 
            box-shadow: 0 4px 20px rgba(0,0,0,0.03); 
        }
        
        body.dark-mode header { 
            background-color: rgba(5, 5, 5, 0.85); 
            backdrop-filter: blur(12px); 
        }

        .logo-container { cursor: pointer; pointer-events: auto; }
        
        /* PC 로고 크기 확대 */
        .logo-img { 
            height: 60px; 
            width: auto; display: block; 
            transition: height 0.3s ease, filter 0.5s ease; 
        }
        
        body.dark-mode .logo-img { filter: invert(1); }

        /* [네비게이션] */
        nav ul { display: flex; list-style: none; gap: 50px; }
        nav ul li { margin-left: 0; }

        nav ul li a {
            text-decoration: none; 
            color: #111111; 
            font-size: clamp(15px, 1.2vw, 18px); 
            font-weight: 400;
            display: block; padding: 10px 0; letter-spacing: -0.02em;
            opacity: 0.8; 
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), color 0.5s ease;
            pointer-events: auto;
            position: relative; text-align: center;
        }

        nav ul li a::before {
            display: block; content: attr(title); font-weight: 700; height: 0; overflow: hidden; visibility: hidden;
        }

        body.dark-mode nav ul li a { color: #ffffff; opacity: 0.7; }
        body.dark-mode nav ul li:hover a { opacity: 1; }

        nav ul li:hover a { transform: translateY(-0.33em); opacity: 1; }

        nav ul li.active a { font-weight: 700; opacity: 1; }
        
        nav ul li.active a::after {
            content: ''; display: block; width: 100%; height: 2px; 
            background: currentColor;
            margin-top: 5px; 
            border-radius: 2px;
        }

        /* [모바일 대응] */
        @media (max-width: 768px) {
            header { 
                padding: 15px 20px; 
                flex-direction: column; 
                gap: 15px;
                height: auto;
                background: transparent; 
            }
            
            header.scrolled {
                background-color: rgba(255, 255, 255, 0.9);
                backdrop-filter: blur(15px);
            }
            
            body.dark-mode header { background: rgba(5,5,5,0.9); }
            
            /* 모바일 로고 확대 */
            .logo-img { height: 50px; }
            
            nav { width: 100%; }
            nav ul { justify-content: center; gap: 25px; width: 100%; }
            /* 모바일 폰트 확대 */
            nav ul li a { font-size: 16px; font-weight: 500; }
        }

        /* [인트로 영역] */
        .hero-spacer { height: 180vh; position: relative; }
        
        .sticky-stage {
            position: sticky; top: 0; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; background-color: #fff; z-index: 10; 
            transition: background-color 0.5s ease;
        }
        .chid-anim-container {
            position: relative; display: flex; align-items: center; justify-content: center;
            width: 100%; will-change: transform;
        }
        
        /* 인트로 텍스트 */
        .text-part {
            font-size: clamp(70px, 14vw, 200px); 
            font-weight: 300; line-height: 1; letter-spacing: -0.04em; color: #111;
            transition: color 0.5s ease;
        }
        body.dark-mode .text-part { color: #ffffff; }
        .hidden-text {
            position: absolute; left: 50%; top: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: clamp(80px, 16vw, 220px); 
            font-weight: 800; color: #111; letter-spacing: -0.05em; 
            opacity: 0; white-space: nowrap; z-index: -1; 
        }
        body.dark-mode .hidden-text { color: #ffffff; }
        .quote { font-size: 0.5em; vertical-align: top; margin: 0 0.1em; display: inline-block; font-weight: 300; }

        /* [스크롤 힌트] */
        .scroll-hint {
            position: fixed;
            bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 90;
            
            font-size: 15px; 
            font-weight: 500; letter-spacing: 0.05em; color: #666; opacity: 0.7;
            
            animation: floatUpDown 2s infinite ease-in-out;
            transition: color 0.5s ease, opacity 0.5s ease, visibility 0.5s;
        }
        
        .scroll-arrow svg { width: 28px; height: 28px; stroke: currentColor; stroke-width: 1.5px; }

        @keyframes floatUpDown { 0%, 100% { transform: translate(-50%, 0); } 50% { transform: translate(-50%, 10px); } }
        
        /* 다크 모드일 때 */
        body.dark-mode .scroll-hint { 
            opacity: 0.8; 
            color: #ffffff;
            visibility: visible; 
        }

        /* [추가됨] 최하단 도달 시 투명 처리 클래스 */
        .scroll-hint.reached-bottom {
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none;
        }

        /* [콘텐츠 섹션] */
        .content-section {
            position: relative; z-index: 20; 
            background-color: #fff;
            min-height: 350vh; 
            transition: background-color 0.5s ease;
        }

        /* [눈알 컨테이너] */
        .eyes-container-sticky {
            position: -webkit-sticky; position: sticky;
            top: 50%; transform: translateY(-50%);
            z-index: 50; width: 100%;
            display: flex; justify-content: center;
            pointer-events: none; opacity: 0; visibility: hidden;
            transition: opacity 0.5s ease, top 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .eyes-container-sticky.eyes-revealed { opacity: 1; visibility: visible; }
        
        /* PC: 헤더 아래 눈 위치 */
        .eyes-container-sticky.moved-up { top: 130px; transform: translateY(0); }

        .eyes-wrapper { display: flex; gap: 30px; position: relative; }
        
        .eye-group {
            position: relative;
            display: flex; flex-direction: column; align-items: center;
            width: clamp(60px, 10vw, 140px); 
        }
        
        .eyebrow {
            width: 50%; height: 14px; 
            background-color: transparent; border-top: 5px solid #fff;
            border-radius: 50% 50% 0 0 / 100% 100% 0 0; margin-bottom: 12px; 
            will-change: transform;
        }
        .eye-canvas { 
            display: block; width: 100%; height: auto; 
            will-change: transform; 
        }

        /* [텍스트 스크롤링 컨테이너] */
        .scrolling-text-container {
            position: relative; width: 100%; height: 350vh;
            z-index: 10; opacity: 0; visibility: hidden;
            transition: opacity 0.5s ease;
        }
        .scrolling-text-container.active { opacity: 1; visibility: visible; }

        /* [개별 텍스트 블록] */
        .text-block {
            position: fixed; 
            top: 50vh; 
            left: 0; width: 100%; height: 50vh;
            display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
            padding-top: 20px; pointer-events: none;
            opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease;
        }
        .text-block.active { opacity: 1; visibility: visible; pointer-events: auto; }
        .text-block .reveal-item { opacity: 0; transform: translateY(30px); transition: opacity 0.5s ease, transform 0.5s ease; }
        .text-block.active .reveal-item { opacity: 1; transform: translateY(0); }
        .text-block.active .reveal-item:nth-child(1) { transition-delay: 0.05s; }
        .text-block.active .reveal-item:nth-child(2) { transition-delay: 0.15s; }
        .text-block.active .reveal-item:nth-child(3) { transition-delay: 0.25s; }

        /* 텍스트 스타일 */
        .brand-slogan {
            font-family: 'Pretendard', sans-serif;
            font-size: clamp(2rem, 5vw, 4.5rem);
            font-weight: 800; margin-bottom: 20px; 
            color: #f2f2f2; line-height: 1.1; word-break: keep-all; text-align: center;
        }
        .brand-sub-translation {
            font-family: 'Pretendard', sans-serif;
            font-size: clamp(0.9rem, 1.2vw, 1.2rem);
            font-weight: 300; color: #888; margin-bottom: 30px;
            text-align: center; line-height: 1.5; word-break: keep-all;
        }
        .brand-paragraph {
            font-family: 'Pretendard', sans-serif;
            font-size: clamp(14px, 1.1vw, 17px); 
            line-height: 1.8; color: #e0e0e0; 
            max-width: 650px; 
            margin: 0 auto; 
            word-break: keep-all; font-weight: 300; text-align: center;
        }
        .point-color { color: #FF4D00; font-weight: 700; }
        .text-bold { color: #fff; font-weight: 600; }

        /* [반응형 수정 - 모바일/좁은 화면] */
        @media (max-width: 768px) {
            .eyes-container-sticky.moved-up { top: 180px; } 
            .eye-group { width: clamp(60px, 18vw, 100px); }
            .text-block { top: 45vh; height: 55vh; padding: 0 20px; }
            .brand-slogan { font-size: clamp(1.8rem, 8vw, 3rem); }
        }
    </style>
</head>
<body>

    <header>
        <div class="logo-container" id="back-to-home">
            <img src="img/main/Head Logo.svg" alt="CHID" class="logo-img">
        </div>
        <nav>
            <ul>
                <li class="active"><a href="about.html" class="nav-link" title="About">About</a></li>
                <li><a href="projects.html" class="nav-link" title="Projects">Projects</a></li>
                <li><a href="contact.html" class="nav-link" title="Contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <div class="hero-spacer">
            <div class="sticky-stage">
                <div class="chid-anim-container">
                    <span class="text-part part-left">CH</span>
                    <span class="hidden-text part-center"><span class="quote">"</span>칫<span class="quote">"</span></span>
                    <span class="text-part part-right">ID</span>
                </div>
            </div>
            
            <div class="scroll-hint">
                <span class="scroll-text">Scroll Down</span>
                <span class="scroll-arrow">
                    <svg viewBox="0 0 24 24" fill="none">
                        <path d="M7 10L12 15L17 10" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </span>
            </div>
        </div>

        <section class="content-section">
            <div class="eyes-container-sticky">
                <div class="eyes-wrapper">
                    <div class="eye-group">
                        <div class="eyebrow"></div>
                        <canvas class="eye-canvas"></canvas>
                    </div>
                    <div class="eye-group">
                        <div class="eyebrow"></div>
                        <canvas class="eye-canvas"></canvas>
                    </div>
                </div>
            </div>

            <div class="scrolling-text-container">
                <div class="text-block" id="block-1">
                    <div class="reveal-item">
                        <h2 class="brand-slogan">
                            Not just <span style="font-weight: 300; opacity: 0.5;">Good</span>,<br>
                            It is <span class="point-color" style="font-style: italic;">"Jealousy."</span>
                        </h2>
                    </div>
                    <div class="reveal-item">
                        <p class="brand-sub-translation">
                            단지 좋은 디자인이 아닙니다.<br>
                            경쟁사가 부러워하는 
                            <span style="color: #bbb; font-weight: 600;">'질투하는 디자인'</span>를 설계합니다."
                        </p>
                    </div>
                </div>

                <div class="text-block" id="block-2">
                    <div class="reveal-item">
                        <p class="brand-paragraph">
                            좋은 디자인은 박수를 받지만, 위대한 디자인은 질투를 부릅니다.<br>
                            뻔한 정답 대신, 관습을 비트는 날 선 감각으로 시장의 룰을 바꿉니다.<br>
                        </p>
                    </div>
                    <div class="reveal-item" style="margin-top: 30px;">
                        <p class="brand-paragraph">
                            경쟁사들이 동경하고 질투할 수밖에 없는 
                            <span class="point-color">압도적인 격차</span>를 설계합니다.
                        </p>
                    </div>
                </div>

                <div class="text-block" id="block-3">
                    <div class="reveal-item">
                        <p class="brand-paragraph">
                             제품이 가져야 할 날카로운 본질만 남깁니다.<br>
                             시선을 뺏고, 격차를 만들고, 시장을 선점하는 힘.<br>
                             <span class="text-bold">"칫! [CHID]"</span> 하는 질투를 이끌어냅니다.
                        </p>
                    </div>
                    <div class="reveal-item" style="margin-top: 30px;">
                        <p class="brand-paragraph">
                            확실한 차이를 만들겠습니다.
                        </p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            setTimeout(() => { document.body.classList.add('fade-in'); }, 50);

            const header = document.querySelector('header');
            const scrollHint = document.querySelector('.scroll-hint');

            // [스크롤 감지]
            window.addEventListener('scroll', () => {
                const scrollY = window.scrollY;
                const windowHeight = window.innerHeight;
                const docHeight = document.documentElement.scrollHeight;

                // 1. 헤더 투명도 처리
                if (scrollY > 50) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }

                // 2. [추가됨] 스크롤 힌트 최하단 숨김 처리
                // 페이지 하단까지 스크롤 되었는지 확인 (오차 50px 여유 둠)
                if (scrollY + windowHeight >= docHeight - 50) {
                    scrollHint.classList.add('reached-bottom');
                } else {
                    scrollHint.classList.remove('reached-bottom');
                }
            });

            // [페이지 이동 함수]
            function fadeAndMove(destinationUrl) {
                if(window.location.href.includes(destinationUrl)) return;
                document.body.classList.remove('fade-in'); 
                setTimeout(() => {
                    window.location.href = destinationUrl; 
                }, 500);
            }

            // [네비게이션 연결]
            document.getElementById('back-to-home').addEventListener('click', function() { 
                fadeAndMove('index.html'); 
            });
            
            document.querySelectorAll('.nav-link').forEach(link => { 
                link.addEventListener('click', function(e) { 
                    e.preventDefault(); 
                    fadeAndMove(this.getAttribute('href')); 
                }); 
            });

            // [변수 설정]
            const spacer = document.querySelector('.hero-spacer');
            const leftPart = document.querySelector('.part-left');
            const rightPart = document.querySelector('.part-right');
            const centerPart = document.querySelector('.part-center');
            const animContainer = document.querySelector('.chid-anim-container');
            const contentSection = document.querySelector('.content-section');
            const eyesContainer = document.querySelector('.eyes-container-sticky');
            const textContainer = document.querySelector('.scrolling-text-container');
            const textBlocks = document.querySelectorAll('.text-block');

            function easeOutExpo(x) { return x === 1 ? 1 : 1 - Math.pow(2, -10 * x); }

            // [1. 인트로 스크롤 애니메이션]
            window.addEventListener('scroll', () => {
                if(!spacer) return;
                const scrollY = window.scrollY;
                const spacerHeight = spacer.offsetHeight - window.innerHeight; 
                const rawProgress = Math.min(Math.max(scrollY / spacerHeight, 0), 1); 
                const smoothProgress = easeOutExpo(rawProgress);

                const scaleFactor = 1.1 - (smoothProgress * 0.1); 
                animContainer.style.transform = `scale(${scaleFactor})`;

                const centerWidth = centerPart.offsetWidth;
                const dynamicGap = (centerWidth * 1.5 / 2) + (window.innerWidth * 0.1); 
                const moveX = dynamicGap * smoothProgress;
                
                leftPart.style.transform = `translateX(-${moveX}px)`;
                rightPart.style.transform = `translateX(${moveX}px)`;

                const blurValue = rawProgress * 20;
                let sideOpacity = 1;
                if (rawProgress > 0.2) sideOpacity = 1 - ((rawProgress - 0.2) / 0.8);
                
                leftPart.style.filter = `blur(${blurValue}px) opacity(${Math.max(0, sideOpacity)})`;
                rightPart.style.filter = `blur(${blurValue}px) opacity(${Math.max(0, sideOpacity)})`;

                let centerOpacity = (rawProgress - 0.25) * 2; 
                centerPart.style.opacity = Math.max(0, Math.min(1, centerOpacity));
                
                const centerScale = 0.6 + (easeOutExpo(Math.max(0, (rawProgress - 0.2) * 1.25)) * 0.4); 
                centerPart.style.transform = `translate(-50%, -50%) scale(${centerScale})`;
            });

            // [2. 눈 & 텍스트 등장 시나리오]
            window.addEventListener('scroll', () => {
                if (!contentSection) return;
                const rect = contentSection.getBoundingClientRect();
                const sectionTop = rect.top;
                const sectionHeight = rect.height;
                const windowHeight = window.innerHeight;

                if (sectionTop <= 100) { 
                    document.body.classList.add('dark-mode');
                    eyesContainer.classList.add('eyes-revealed');
                    textContainer.classList.add('active');
                } else {
                    document.body.classList.remove('dark-mode');
                    eyesContainer.classList.remove('eyes-revealed');
                    textContainer.classList.remove('active');
                    eyesContainer.classList.remove('moved-up');
                }

                // 이동 및 텍스트 전환
                const startOffset = windowHeight * 0.5; 
                let scrollProgress = (windowHeight - sectionTop - startOffset) / (sectionHeight - startOffset);
                scrollProgress = Math.max(0, scrollProgress);

                if (scrollProgress > 0.05) { eyesContainer.classList.add('moved-up'); } 
                else { eyesContainer.classList.remove('moved-up'); }

                let textProgress = (scrollProgress - 0.15) * 1.2; 
                textProgress = Math.max(0, textProgress);
                let activeIndex = Math.floor(textProgress * textBlocks.length);
                if (activeIndex < 0) activeIndex = -1;
                if (activeIndex >= textBlocks.length) activeIndex = textBlocks.length - 1;

                textBlocks.forEach((block, index) => {
                    if (index === activeIndex) block.classList.add('active');
                    else block.classList.remove('active');
                });
            });

            // [3. 눈알 애니메이션]
            const eyeGroups = document.querySelectorAll('.eye-group');
            if (eyeGroups.length > 0) {
                let mouseX = window.innerWidth / 2; 
                let mouseY = window.innerHeight / 2;
                let isIdle = true; 
                let mouseStopTimer;
                
                let eyeStates = [
                    { cx: 0, cy: 0, tx: 0, ty: 0, currentOpen: 1, isBlinking: false, isSquinting: false, shiftCx: 0, shiftCy: 0 }, 
                    { cx: 0, cy: 0, tx: 0, ty: 0, currentOpen: 1, isBlinking: false, isSquinting: false, shiftCx: 0, shiftCy: 0 }
                ];
                let eyebrowLiftState = [ { cur: 0, tar: 0 }, { cur: 0, tar: 0 } ];

                const canvases = [];
                eyeGroups.forEach((group) => {
                    const canvas = group.querySelector('.eye-canvas');
                    const ctx = canvas.getContext('2d');
                    canvases.push({canvas, ctx});
                });

                function resizeCanvases() {
                    canvases.forEach(({canvas}) => {
                        const rect = canvas.parentElement.getBoundingClientRect();
                        canvas.width = rect.width * 2; canvas.height = (rect.width * 0.75) * 2;
                        canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.width * 0.75}px`;
                    });
                }
                window.addEventListener('resize', resizeCanvases); resizeCanvases();
                
                function lerp(s, e, f) { return s + (e - s) * f; }
                
                function drawEye(ctx, width, height, openRatio, gazeX, gazeY) {
                    ctx.clearRect(0, 0, width, height); 
                    ctx.save(); 
                    ctx.translate(width / 2, height / 2);
                    
                    const maxRadiusX = width / 2 - 2; 
                    const maxRadiusY = height / 2 - 2;
                    const radiusX = maxRadiusX; 
                    const radiusY = Math.max(0, maxRadiusY * openRatio);
                    
                    ctx.beginPath();
                    if (radiusY > 0) { ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2); } 
                    else { ctx.moveTo(-radiusX, 0); ctx.lineTo(radiusX, 0); }
                    ctx.closePath(); 
                    ctx.fillStyle = '#ffffff'; ctx.fill();
                    
                    if (radiusY > 0) {
                        const pupilSize = width * 0.35; 
                        const pupilX = gazeX * 2; 
                        const pupilY = gazeY * 2 * openRatio; 
                        
                        ctx.beginPath(); 
                        ctx.arc(pupilX, pupilY, pupilSize / 2, 0, Math.PI * 2); 
                        ctx.fillStyle = '#050505'; ctx.fill();

                        ctx.beginPath();
                        ctx.arc(pupilX + pupilSize * 0.15, pupilY - pupilSize * 0.15, pupilSize * 0.12, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fill();
                    }
                    ctx.restore();
                }

                function handleInput(x, y, timeout) {
                    mouseX = x; mouseY = y;
                    isIdle = false;
                    clearTimeout(mouseStopTimer);
                    eyeStates.forEach(s => s.isSquinting = false);
                    mouseStopTimer = setTimeout(() => { isIdle = true; pickRandomGaze(); }, timeout);
                }

                document.addEventListener('mousemove', (e) => { 
                    handleInput(e.clientX, e.clientY, 600); 
                });

                document.addEventListener('touchstart', (e) => {
                    if(e.touches.length > 0) {
                        handleInput(e.touches[0].clientX, e.touches[0].clientY, 1000); 
                    }
                }, {passive: true});

                document.addEventListener('touchmove', (e) => {
                     if(e.touches.length > 0) {
                        handleInput(e.touches[0].clientX, e.touches[0].clientY, 1000); 
                    }
                }, {passive: true});

                function pickRandomGaze() { 
                    if (!isIdle) return; 
                    const angle = Math.random() * Math.PI * 2; 
                    const distance = 20 + Math.random() * 10; 
                    eyeStates.forEach((state) => { 
                        state.tx = Math.cos(angle) * distance; 
                        state.ty = Math.sin(angle) * distance; 
                    }); 
                    setTimeout(pickRandomGaze, Math.random() * 2000 + 1500); 
                }
                setTimeout(pickRandomGaze, 100); 

                function triggerRandomEyebrow() { 
                    const pick = Math.random() > 0.5 ? 1 : 0; 
                    eyebrowLiftState[pick].tar = 30; 
                    setTimeout(() => { 
                        eyebrowLiftState[pick].tar = 0; 
                        setTimeout(triggerRandomEyebrow, Math.random() * 3000 + 2000); 
                    }, 600); 
                }
                setTimeout(triggerRandomEyebrow, 2000);

                function triggerRandomSquint() {
                    if (isIdle) {
                        eyeStates.forEach(s => s.isSquinting = true);
                        setTimeout(() => {
                            eyeStates.forEach(s => s.isSquinting = false);
                            scheduleNextSquint();
                        }, Math.random() * 1000 + 2000);
                    } else {
                        scheduleNextSquint();
                    }
                }
                function scheduleNextSquint() { setTimeout(triggerRandomSquint, Math.random() * 5000 + 5000); }
                setTimeout(scheduleNextSquint, 5000);

                function animateEyes() {
                    const now = Date.now();
                    
                    eyeGroups.forEach((group, index) => {
                        const { canvas, ctx } = canvases[index]; 
                        const state = eyeStates[index]; 
                        const liftState = eyebrowLiftState[index]; 
                        const eyebrow = group.querySelector('.eyebrow');
                        
                        let shiftX = 0, shiftY = 0; 

                        if (!isIdle) {
                            const rect = canvas.getBoundingClientRect(); 
                            const eyeCenterX = rect.left + rect.width / 2; 
                            const eyeCenterY = rect.top + rect.height / 2;
                            
                            const angle = Math.atan2(mouseY - eyeCenterY, mouseX - eyeCenterX); 
                            const dist = Math.hypot(mouseX - eyeCenterX, mouseY - eyeCenterY);
                            
                            // 화면 비율에 따른 주시 강도 조절
                            const maxScreenDist = Math.hypot(window.innerWidth/2, window.innerHeight/2);
                            let intensity = dist / maxScreenDist;
                            if (intensity > 1) intensity = 1; 

                            const pupilRadius = (rect.width * 0.35) / 2;
                            const safeLimit = (rect.width / 2) - pupilRadius - 2;
                            const extremeLimit = safeLimit * 1.3;

                            const moveDistance = extremeLimit * intensity;
                            
                            state.tx = Math.cos(angle) * moveDistance; 
                            state.ty = Math.sin(angle) * moveDistance;

                            const maxEyeShift = 10; 
                            shiftX = Math.cos(angle) * (maxEyeShift * intensity);
                            shiftY = Math.sin(angle) * (maxEyeShift * intensity);
                        }
                        
                        state.shiftCx = lerp(state.shiftCx, shiftX, 0.1);
                        state.shiftCy = lerp(state.shiftCy, shiftY, 0.1);
                        canvas.style.transform = `translate(${state.shiftCx}px, ${state.shiftCy}px)`;

                        state.cx = lerp(state.cx, state.tx, 0.15); 
                        state.cy = lerp(state.cy, state.ty, 0.15);
                        
                        let targetOpen = 1.0;
                        if (state.isBlinking) targetOpen = 0.0;
                        else if (state.isSquinting) targetOpen = 0.4; 

                        state.currentOpen = lerp(state.currentOpen, targetOpen, 0.2);
                        
                        drawEye(ctx, canvas.width, canvas.height, state.currentOpen, state.cx, state.cy);
                        
                        liftState.cur = lerp(liftState.cur, liftState.tar, 0.1);
                        
                        const screenY = mouseY / window.innerHeight; 
                        const baseLift = Math.max(0, (0.5 - screenY) * 20); 
                        const screenX = (mouseX / window.innerWidth) - 0.5; 
                        const baseRotate = screenX * 10; 
                        let waveOffset = (index === 0) ? Math.sin(now / 800) * 3 : Math.cos(now / 600) * 3; 
                        
                        const squintOffset = state.isSquinting ? 5 : 0;
                        const totalLift = baseLift + liftState.cur - squintOffset; 
                        const totalRotate = baseRotate + waveOffset; 
                        
                        if(eyebrow) {
                            eyebrow.style.transform = `translateY(-${totalLift}px) rotate(${totalRotate}deg)`;
                        }
                    });
                    
                    requestAnimationFrame(animateEyes);
                }
                animateEyes();

                function triggerRandomBlink() { 
                    eyeStates.forEach(s => s.isBlinking = true); 
                    setTimeout(() => { 
                        eyeStates.forEach(s => s.isBlinking = false); 
                        scheduleNextBlink(); 
                    }, 150); 
                }
                function scheduleNextBlink() { setTimeout(triggerRandomBlink, Math.random() * 4000 + 2000); }
                scheduleNextBlink();
            }
        });
    </script>
</body>
</html>
